namespace Apollon.Lib
{
    using Apollon.Lib.DualRules;
    using Apollon.Lib.Graph;
    using Apollon.Lib.Linker;
    using Apollon.Lib.Logging;
    using Apollon.Lib.NMRCheck;
    using Apollon.Lib.OLON;
    using Apollon.Lib.Resolution;
    using Apollon.Lib.Resolution.CallStackAndCHS;
    using Apollon.Lib.Resolution.CoSLD;
    using Apollon.Lib.Rules;
    using Apollon.Lib.Unification;

    /// <summary>
    /// This class is the high level function in order to solve a asp program.
    /// </summary>
    public class Solver
    {
        /// <summary>
        /// Gets an Enumerable of all ProcessedStatements.
        /// </summary>
        public IEnumerable<Statement>? ProcessedStatements { get; private set; }

        /// <summary>
        /// Gets or sets the Resolution.
        /// </summary>
        public IResolution Resolution { get; set; } = new CoSLDResolution();

        /// <summary>
        /// Gets or sets the VariableLinker.
        /// </summary>
        public IVariableLinker VariableLinker { get; set; } = new VariableLinker();

        /// <summary>
        /// Gets or sets the NMRCheckGenerator.
        /// </summary>
        public INMRCheckGenerator NmrCheckGenerator { get; set; } = new NMRCheckGenerator();

        /// <summary>
        /// Gets the loaded Program.
        /// </summary>
        public Program? LoadedProgram { get; private set; }

        /// <summary>
        /// Gets or sets the Logger.
        /// </summary>
        public ILogger Logger { get; set; } = new ConsoleLogger();

        private Statement? NMRCheck { get; set; }

        /// <summary>
        /// Loads a program into the solver.
        /// </summary>
        /// <param name="program">The loaded program generated by the parser/lexer.</param>
        public void Load(Program program)
        {
            IDualRuleGenerator dualRuleGenerator = new DualRuleGenerator();

            var callGraph = new CallGraphBuilder(new LiteralParamCountEqualizer()).BuildCallGraph(program);
            this.LogCallGraphIfNeeded(callGraph);

            var olons = OlonDetector.DetectOlonIn(callGraph);

            var rulePreprocessor = new RuleMetadataSetter(callGraph, olons);
            var processedRules = rulePreprocessor.SetMetadataOn(program.RuleTypesAsStatements.ToArray());
            this.LogProcessedRulesIfNeeded(processedRules);

            var dualRules = dualRuleGenerator.GenerateDualRules(program.Statements.ToArray());
            var nmrRules = this.NmrCheckGenerator.GenerateNMRCheckRules(processedRules, program);

            this.NMRCheck = nmrRules.Last();
            this.ProcessedStatements = program.Statements.Union(dualRules).Union(nmrRules).Select(s => (Statement)s.Clone()).Select(s => this.VariableLinker.LinkVariables(s)).ToArray();
            this.LoadedProgram = program;

            var processedStatements = new List<Statement>();
            var variableExtractor = new VariableExtractor();

            // foreach (var s in ProcessedStatments)
            // {
            //     var variables = variableExtractor.ExtractVariablesFrom(s);
            //     foreach (var variable in variables)
            //     {
            //         var newName = $"RV/{variableIndex}";
            //
            //         variable.Value = newName;
            //         variableIndex++;
            //     }
            // }
            this.Logger.Info($"Loaded and preprocessed program: \n{string.Join("\n", this.ProcessedStatements)}");
        }

        /// <summary>
        /// This function solves the asp program with the given goals.
        /// </summary>
        /// <param name="goals">The goals the asp program should solve to.</param>
        /// <returns>An Enumerable of all Answer Sets piece by piece.</returns>
        /// <exception cref="InvalidOperationException">Is thrown if no program was loaded beforehand.</exception>
        public IEnumerable<ResolutionResult> Solve(BodyPart[] goals)
        {
            if (this.ProcessedStatements == null)
            {
                throw new InvalidOperationException("No program loaded.");
            }

            var linkedGoals = this.VariableLinker.LinkVariables(new Statement(null, goals)).Body;

            var nMRCheckGoal = new BodyPart(((Statement)this.NMRCheck.Clone()).Head, null);
            var goalsCopy = linkedGoals.Select(g => (BodyPart)g.Clone())
                .Append(nMRCheckGoal)
                .ToArray();

            var results = this.Resolution.Resolute(this.ProcessedStatements.ToArray(), goalsCopy, this.Logger);

            foreach (var res in results)
            {
                yield return this.PostProcessResult(goals, res);
            }
        }

        private ResolutionResult PostProcessResult(BodyPart[] goals, ResolutionResult res)
        {
            // get the values of the variables of the query. as the result has the variables filled in.
            var unifier = new Unifier();
            var variableExtractor = new VariableExtractor();

            // remove all answers that are not in the original program
            var final = new List<Literal>();

            // ignore naf negation when selecting literals.
            var allLiterals = this.LoadedProgram.AllLiterals.Select(l =>
            {
                l.IsNAF = false;
                return l;
            }).ToArray();
            foreach (var literal in res.CHS.Literals)
            {
                // if literal exists in programm add it to final
                var litCopy = (Literal)literal.Clone();
                litCopy.IsNAF = false;
                if (allLiterals.Where(l => unifier.Unify(l, litCopy).IsSuccess).Any())
                {
                    final.Add(literal);
                }
            }

            return new ResolutionResult(new CHS(final), res.Substitution);
        }

        private void LogProcessedRulesIfNeeded(IEnumerable<PreprocessedStatement> rules)
        {
            if (this.Logger.Level > LogLevel.Debug)
            {
                return;
            }

            this.Logger.Debug("Tagged Rules:");

            foreach (var rule in rules)
            {
                this.Logger.Debug($"  {rule}");
            }
        }

        private void LogCallGraphIfNeeded(CallGraph callGraph)
        {
            if (this.Logger.Level > LogLevel.Debug)
            {
                return;
            }

            this.Logger.Debug("Created Call Graph:");
            this.Logger.Debug("  Nodes:");
            foreach (var node in callGraph.Nodes)
            {
                this.Logger.Debug($"    {node}");
            }

            this.Logger.Debug("  Edges:");
            foreach (var edge in callGraph.Edges)
            {
                this.Logger.Debug($"    {edge}");
            }
        }
    }
}
